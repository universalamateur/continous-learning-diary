# Daily Learning Journal - 2021-10-20 - Wednesday

## Typing Academy

Daily [typing lessons](https://www.typing.academy/typing-tutor/lessons)

## Greek Language

[DuoLingo greek](https://www.duolingo.com/learn)

## Application security testing

### Fuzzing 101 presentation

> Present a short (ca. 15m) presentation on Fuzzing covering the following points:

1. Overview of application security testing (e.g. SAST and DAST)
2. Fuzzing overview
3. What is fuzzing
4. How does it work
5. What can and canâ€™t it do (very high level e.g;. Fuzzing is not good for
testing X, Y, Z)
6. Whitebox vs blackbox fuzzing

### Overview SAST

Static Application Security Testing, in short SAST, is an Analysis of the source code of an application for possible vulnerabilities.
This can be done in the IDE or the in the CI Pipeline in a Merge or Pull Request, helping the developer producing more secure code.

As example in this python code a possible SQL injection lurks and would be detected by a SAST Tool, either giving an alert in the IDE or rejecting the Merge or Pull Request with the reference to the issue:

```python
def run_query(query):
    """ Returns the results from a SQL query
    """
    connection = create_sql_conection()
    result = connection.execute(query)
    return result

@app.route('/about/<string:username>')
def about_user(username):
    """ Returns the users profile from the database to the web front end
    """
    sql_query = f'SELECT * FROM profiles WHERE user_id = {username}'
    result = run_query(sql_query)
    return f'<p>{result}</p>'
```

SAST and its Tools integration into an existing Software Development Life Cycle (SDLC) is straightforward and scales well. It supports the developer directly and comprehensible with certain vulnerabilities and full code coverage. Overall SAST Tools lessen the risk and therefore the cost of insecure code being introduced to an application.
They can not catch all vulnerabilities and should always only be one of the tools used in the DevSecOps setup of any Software delivery chain.
False-positives and the noise generated by SAST tools, are the downside. This could lead to mistrust into the Tool and heightend cost through investigation of those alerts.

### Overview DAST

Dynamic application security testing, in short DAST, is an automated software testing technique of an application in runtime for possible vulnerabilities, probing it from the ourside.
This can be done fully automaticly as a stage in a testing enviroment of a CI Pipeline after a merge or pull request. The resulting security report will show the passed and failed tests with possible warnings and alerts.

as an example here the output of a ZAP - Baseline Scan:

```log
docker run -t owasp/zap2docker-stable zap-baseline.py -t https://www.example.com
May 17, 2016 1:24:32 PM java.util.prefs.FileSystemPreferences$1 run
INFO: Created user preferences directory.
Total of 3 URLs
PASS: Cookie No HttpOnly Flag [10010]
PASS: Cookie Without Secure Flag [10011]
PASS: Password Autocomplete in Browser [10012]
PASS: Cross-Domain JavaScript Source File Inclusion [10017]
PASS: Content-Type Header Missing [10019]
PASS: Information Disclosure - Debug Error Messages [10023]
PASS: Information Disclosure - Sensitive Informations in URL [10024]
PASS: Information Disclosure - Sensitive Information in HTTP Referrer Header [10025]
PASS: HTTP Parameter Override [10026]
PASS: Information Disclosure - Suspicious Comments [10027]
PASS: Viewstate Scanner [10032]
PASS: Secure Pages Include Mixed Content [10040]
PASS: Weak Authentication Method [10105]
PASS: Private IP Disclosure [2]
PASS: Session ID in URL Rewrite [3]
PASS: Absence of Anti-CSRF Tokens [40014]
PASS: Script passive scan rules [50001]
PASS: Insecure JSF ViewState [90001]
PASS: Charset Mismatch [90011]
PASS: Application Error Disclosure [90022]
PASS: WSDL File Passive Scanner [90030]
PASS: Loosely Scoped Cookie [90033]
WARN: Incomplete or No Cache-control and Pragma HTTP Header Set [10015] x 3
	https://www.example.com
	https://www.example.com/robots.txt
	https://www.example.com/sitemap.xml
WARN: Web Browser XSS Protection Not Enabled [10016] x 3
	https://www.example.com
	https://www.example.com/robots.txt
	https://www.example.com/sitemap.xml
WARN: X-Frame-Options Header Not Set [10020] x 3
	https://www.example.com
	https://www.example.com/robots.txt
	https://www.example.com/sitemap.xml
WARN: X-Content-Type-Options Header Missing [10021] x 3
	https://www.example.com
	https://www.example.com/robots.txt
	https://www.example.com/sitemap.xml
FAIL: 0	WARN: 4	IGNORE: 0	PASS: 22
```

DAST and its Tools are conecntrating on In- and Output of an application. They count as black-box security testing methodology, challenging the applications automized with sets of valid and invalid inputs including checking for well-known security vulnerabilities. Overall DAST Tools test the complete application in deployed status similar to an attacker and can help prevent security breaches, reudcing the risk of financial and other damages.
DAST does not gurantee full code or attack surface coverage. Found vulnerabilities in the security report have to be validated manualy and then investigated, before those can be remidiated. This can break a fully automized CI Pipeline.

### Fuzzing Overview

Fuzzing (or Fuzz Testing) is an automated software testing technique of an application in runtime with invalid, unexpected, or random input while monitoring the application for hangs, crashes or exceptions.
The first generations of Fuzz tests were quite blind and unguided, bringing value none the less. Using different structured inputs of apllications like files, network data, stdin, UI interaction, API usage and others, the Fuzzer tries to create unexpected behaviors deeper in the program. Occured incidents are listed in a report with the used input for debugging the program and identifying the source of the found bug.
To improve the results of Fuzz Testing, some fuzzers accept an input seed, based on which they can mutate the input to find unexpected behaviour. Another approach for improvement is to give the Fuzzer the specification of the legal inputs to a program, the Grammar.
With these upgrades, the Code Coverage of a Fuzzer is still an issue. Even with the best seed or Grammar, a Fuzzer might not call all the functions of an application, reach all parts of a program and execute them.
Turning the black-box into a grey-box Fuzz Testing methology gives the results another metric, the former mentioned Code Coverage. Coverage guided fuzzing uses program instrumentation to trace the code coverage reached by each input fed to a fuzz target.
For this the Fuzz Tester has to be aware of the source code, in many cases even integrating itself into it for a succesful test. The added advantage is a full calltrace for the debugging of the found bugs in the Fuzz Test.
The necessary instrumentation for measuring the code coverage and keeping teck of the trace call, is language dependant included in the running application, while deployed to the Fuzz Test Enviroment.
For low code languages like C++, the source code is compiled with added instrumentation, either inserted into the source code or introduced by the compiler. For byte code languages like Java a "Fuzzing Agent" is added and modifys the JVM bytecode during runtime. Script languages like python, can include Fuzz libaries and execute with these added functionalities.
